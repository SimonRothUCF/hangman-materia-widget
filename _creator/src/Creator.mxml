<?xml version="1.0" encoding="utf-8"?>
<materia:CreatorBase xmlns:mx="http://www.adobe.com/2006/mxml"
					 xmlns:materia="materia.*"
					 xmlns:components="materia.components.*"
                     xmlns:questionAnswerDataGrid="materia.components.questionAnswerDataGrid.*"
                     xmlns:help="materia.help.*"
                     width="100%" height="100%"
                     backgroundColor="#3B3E40"
                     horizontalScrollPolicy="off" verticalScrollPolicy="off">
<mx:Script>
<![CDATA[
	import events.CategoryEvent;
	import events.ConfirmDeleteEvent;

	import materia.CreatorConfig;
	import materia.questionStorage.Question;
	import materia.questionStorage.QuestionGroup;
	import materia.questionStorage.QuestionSet;

	import mx.collections.ArrayCollection;
	import mx.controls.Alert;
	import mx.events.CloseEvent;
	import mx.events.FlexEvent;
	import mx.events.ListEvent;
	import mx.managers.PopUpManager;

		//--------------------------------------------------------------------------
		//
		//  Variables
		//
		//--------------------------------------------------------------------------
		//----------------------------------
		//  Default vars
		//----------------------------------
		[Bindable]
		/**
		 *  Default info to show in the category list on load
		 */
		public var categoryList:ArrayCollection = new ArrayCollection();
		//----------------------------------
		//  Other vars
		//----------------------------------
		/**
		 *  The dialog window to handle questions when a category is deleted.
		 */
		private var cd:ConfirmDelete;
		/**
		 *  Stores the currently selected category index
		 */
		private var _currentCategory:int;

		private var importedQuestions:Array;

		private var LEGAL_PATT:RegExp = new RegExp("[a-zA-Z0-9]", "i")
		//--------------------------------------------------------------------------
		//
		//  Overridden methods
		//
		//--------------------------------------------------------------------------

		public override function onSaveClicked(mode:String = 'save'):void
		{
			var qSet:Object = generateQSET();
			scrubErrorsFromQSet(qSet);

			if(!checkForErrors())
			{
				ExternalInterface.call("__materia_flash_save", instanceTitle, qSet, questionSetVersion);
			}
			else
			{
				ExternalInterface.call("__materia_flash_cancelSave")
			}
		}
		/**
		 *	Called first when editor is loaded (for new games and edited games alike)
		 */
		public override function init():void
		{
			super.init();
			instanceTitle = "New Hangman Widget"
			this.addEventListener(CategoryEvent.CATEGORY_CLICK, onCategoryClick, false, 0, true);
			this.addEventListener(CategoryEvent.CATEGORY_DELETE, onDeleteCategory, false, 0, true);
			if (categoryList.length == 0)
			{
				newCategory();
			}
			//Manage Datagrid
			questionInputList.addEventListener(ListEvent.CHANGE, onDatagridChange, false, 0, true);
			questionInputList.answerColumn.characterLimit = 34;
			questionInputList.equalizeColumnWidths();
			if (_inst_id === -1) // check if this is not a widget that already contains a working qSet
			{
				questionInputList.addQuestion(null, false);
			}
		}
		/**
		 *	Called after init() when game is edited (loaded with a qset)
		 */
		protected override function initExistingWidget(title:String, widget:Object, qset:Object, version:String, baseUrl:String):void
		{
			super.initExistingWidget(title, widget, qset, version, baseUrl);
			categoryList.removeAll();
			for (var i:int = 0; i < questionSet.items.length; i++)
			{
				newCategory(questionSet.items[i].name);
				for (var j:int = 0; j < questionSet.items[i].items.length; j++)
				{
					questionInputList.addQuestion(questionSet.items[i].items[j]);
				}
			}

			if (questionSet.options["attempts"] != null)
			{
				attemptsSlider.value = questionSet.options["attempts"];
			}
			if (questionSet.options["partial"] != null)
			{
				partialScoring.selected = questionSet.options["partial"];
			}
			if (categoryList.length > 0)
			{
				// setSelectedCategory was not working here for some reason
				categoryTL.selectedIndex = 0;
			}
		}
		/**
		 *	Called once for each question that was selected to be imported.
		 */
		public override function addImportedQuestion(question:Question):Question
		{
			var q:Question = super.addImportedQuestion(question);
			var q2:Question = new Question('QA', null, q.id);
			q2.addAnswer(q.answers[0].text);
			q2.addQuestion(q.questions[0].text);
			questionInputList.addQuestion(q2, false);
			categoryList[categoryTL.selectedIndex]["items"]++;
			categoryTL.dataProvider.refresh();
			return q;
		}

		private function debug_traceQuestions():void
		{
			for(var i:int = 0; i < questionInputList.dataProvider.length; i++)
			{
				trace(i, questionInputList.dataProvider[i].question);
				trace(i, questionList.getItemAt(i).question);
			}
		}

		//--------------------------------------------------------------------------
		//
		//  Methods
		//
		//--------------------------------------------------------------------------
		/**
		 *	 Build qset for saving/publishing
		 */
		private function generateQSET():Object
		{
			var _qSet:QuestionSet = new QuestionSet(txtGameTitle.text);
			for (var i:int = 0; i < categoryList.length; i++)
			{
				// NOTE: making this so it does not change questionInputList's dataprovider
				//    it was refreshing the list, which would scroll it to the top.
				//    that is annoying when it is auto-saving behind the scenes
				var catQGroup:QuestionGroup =
						QuestionAnswerDataGrid.generateQGroupFromDataProvider(categoryList[i].dataProvider,
								txtGameTitle.text);
				if (catQGroup.length > 0)
				{
					_qSet.addGroup(catQGroup);
				}
			}
			_qSet.options["attempts"] = attemptsSlider.value;
			_qSet.options["partial"] = partialScoring.selected;
			validateQIDs(_qSet); // make sure it is right to send the qids we are sending
			return _qSet.convertToObject();
		}
		/**
		 *	Check to make sure we have valid info everywhere
		 *
		 *	<p>Will display an Alert with the errors found</p>
		 *
		 *	@return A value of <code>true</code> means there was an error;
		 *	A value of <code>false</code> means there is no error.
		 */
		private function checkForErrors():Boolean
		{
			// problems with the game title will be caught by the popup on publishing
			if (questionInputList.numQuestions == 0)
			{
				Alert.show("You must have at least one question.", "Question Error")
				return true
			}
			if (questionInputList.numQuestions > 30)
			{
				Alert.show("You have exceeded the maximum of 30 questions for this game. Please remove questions until you have 30 or less.")
				return true
			}
			var tempAC:ArrayCollection = ArrayCollection(questionInputList.dataProvider)

			for (var i:Number = 0; i < tempAC.length; i++)
			{
				if(i + 1 == tempAC.length) break

				var questionRow:Object = tempAC.getItemAt(i)
				if (questionRow.question.answer == "" || questionRow.question.question == "")
				{
					Alert.show("You cannot have empty fields. Please either fill out missing data or delete partially complete questions.", "Question Error")
					return true
				}
				if (questionRow.question.answer.search(LEGAL_PATT) == -1)
				{
					Alert.show("You cannot use phrases with no letters or numbers.", "Question Error")
					return true
				}
			}

			return false
		}

		/**
		 *	Set the selected category
		 *
		 *	@parem id The position of the category to select.
		 */
		private function setSelectedCategory(id:int):void
		{
			_currentCategory = id;
			categoryTL.addEventListener(FlexEvent.UPDATE_COMPLETE, handleSetSelectedCategory, false, 0, true);
		}
		/**
		 *	Finish the select category process.
		 *
		 *	<p>Seperated because we have to wait for the category TileList to finish updating.</p>
		 */
		private function handleSetSelectedCategory(e:FlexEvent):void
		{
			categoryTL.selectedIndex = _currentCategory;
			categoryTL.removeEventListener(FlexEvent.UPDATE_COMPLETE, handleSetSelectedCategory);
		}
		/**
		 *	Selects all the text in the component that calls it.
		 */
		private function hightlight(e:FocusEvent):void
		{
			e.currentTarget.setSelection(0, e.currentTarget.text.length);
		}
		/**
		 *	Called when a category item is clicked from the TileList
		 */
		private function onCategoryClick(e:Event):void
		{
			_currentCategory = e.target.data.pos;
			questionInputList.dataProvider = categoryList[_currentCategory].dataProvider;
		}
		private function onDatagridChange(event:Event):void
		{
			categoryList[_currentCategory]["items"] = categoryList[_currentCategory].dataProvider.length - 1;
			categoryList.refresh();
		}
		/**
		 *	Called when a category is chosen to be deleted.
		 */
		private function onDeleteCategory(e:Event):void
		{
			e.stopPropagation();
			//1. if its the last category, alert they cant delete.
			//2. if the category has no questions just delete it.
			//3. if it has questions, show a prompt asking what to do
			if (categoryList.length <= 1)
			{
				Alert.show("Cannot delete \"" + e.target.data.name + "\" becaue there must be at least one category.", "Delete Category");
			}
			else
			{
				var newCatList:ArrayCollection = new ArrayCollection();
				//we want a copy of the array of categories, not a refrence, so copy:
				for (var i:int = 0; i < categoryList.length; i++)
				{
					newCatList.addItem(categoryList.getItemAt(i));
				}
				cd = new ConfirmDelete();
				cd.addEventListener(ConfirmDeleteEvent.CONTINUE_CLICK, onDeleteConfirmed, false, 0, true);
				cd.addEventListener(ConfirmDeleteEvent.CANCEL_CLICK, onDeleteCanceled, false, 0, true);
				//if the category has no questions, just delete it w/o a prompt
				if (categoryList[categoryTL.selectedIndex].dataProvider.length - 1 < 1)
				{
					setTimeout(cd.btnContinue, 10);
				}
				else
				{
					cd.catItem = categoryTL.selectedItem;
					cd.catList = newCatList;
					PopUpManager.addPopUp(cd, this, true);
					PopUpManager.centerPopUp(cd);
				}
			}
		}
		/**
		 *	Function.
		 */
		private function onDeleteCanceled(e:Event):void
		{
			PopUpManager.removePopUp(cd);
		}
		/**
		 *	Called when the delete dialog submit is pressed.
		 */
		private function onDeleteConfirmed(e:ConfirmDeleteEvent):void
		{
			var selectedCategory:int = categoryTL.selectedIndex;
			var movetoCatgoryId:int = -1;
			var moveToCategoryPos:int = 0;
			//decide what to select after the category is deleted.
			var gotoIndex:int = 0;
			if (e.option == "delete")
			{
			}
			else
			{
				movetoCatgoryId = e.moveToCategoryId;
				moveToCategoryPos = e.moveToCategory;
				var fromArray:ArrayCollection = categoryList.getItemAt(selectedCategory).dataProvider;
				var toArray:ArrayCollection = categoryList.getItemAt(moveToCategoryPos).dataProvider;
				for (var i:int = 0; i < fromArray.length; i++)
				{
					toArray.addItem(fromArray.getItemAt(i));
				}
				QuestionAnswerDataGrid.cleanUpDataProvider(toArray);
			}
			categoryList.removeItemAt(selectedCategory);
			this.updateCategoryPos();
			//now we need to figure out what category to select after the remove
			if (e.option == "delete")
			{
				gotoIndex = 0;
			}
			else
			{
				gotoIndex = moveToCategoryPos;
			}
			//make sure there's at least 1 category because theres no point in selecting nothing.
			if (categoryList.length > 0)
			{
				this.setSelectedCategory(gotoIndex);
			}
		}
		/**
		 *	Called when the attempts slider has been adjusted
		 */
		private function updateAttemptsOption(attempts:Number = 0):void{}
		/**
		 *	Called when a new category needs to be added.
		 */
		private function newCategory(name:String = "Category"):void
		{
			if (categoryList.length < 15)
			{
				var newcid:int = this.nextHighestCid();
				categoryList.addItem({cid:newcid, pos:categoryList.length, name:name, items:"0", dataProvider:new ArrayCollection()});
				setSelectedCategory(categoryList.length - 1);
				questionInputList.dataProvider = categoryList[_currentCategory].dataProvider;
				questionInputList.addQuestion(null, false);
			}
			else
			{
				Alert.show("You have reached the maximum of 15 categories.");
			}
		}
		/**
		 *	Find the highest id in the categorylist
		 *
		 *	@return The highest ID in the categoryList
		 */
		private function nextHighestCid():int
		{
			var max:int = 0;
			for (var i:int = 0; i < categoryList.length; i++)
			{
				if (categoryList[i]["cid"] > max)
				{
					max = categoryList[i]["cid"]
				}
			}
			max += 1;
			return max;
		}
		/**
		 *	Called when we need to add a new question
		 */
		private function newQuestion():void
		{
			if (questionInputList.numQuestions + 1 > 30)
			{
				Alert.show("You have reached the maximum number of questions for this game.");
				return;
			}

			questionInputList.addQuestion();
		}

		protected override function importQuestions(questions:Object):void
		{
			importedQuestions = questions as Array;

			if(questionInputList.numQuestions + importedQuestions.length > 30)
			{
				Alert.show("You can't have more than 30 questions per game. If you import these questions you'll need to remove some of them before you publish your game. Do you want to import anyway?", "Notice", Alert.NO | Alert.YES, null, handleCloseAlert);
			}
			else
			{
				finishImportQuestions();
			}
		}

		private function finishImportQuestions():void
		{
			super.importQuestions(importedQuestions);

			debug_traceQuestions();
		}

		private function handleCloseAlert(event:CloseEvent):void
		{
			if(event.detail == Alert.YES)
			{
				finishImportQuestions();
			}
		}

		/**
		 * Sets the datagrid editing to the last element, first column
		 */
		private function editLast():void
		{
		}
		/**
		 *	Update the position of each category because the tilewindow doesn't do it..
		 */
		private function updateCategoryPos():void
		{
			var newCategoryList:ArrayCollection = new ArrayCollection();
			for (var i:int = 0; i < categoryList.length; i++)
			{
				categoryList[i]["pos"] = i;
				newCategoryList.addItem(categoryList.getItemAt(i));
			}
			categoryList.removeAll();
			for (var k:int = 0; k < newCategoryList.length; k++)
			{
				categoryList.addItem(newCategoryList.getItemAt(k));
			}
			categoryTL.dataProvider.refresh();
		}
		/**
		 *	Called when the Publish button is clicked.
		 *
		 *	<p>Method will remove all sets that have both the question and answer text still set as default.</p>
		 *
		 *	<p>Method will remove all categories that don't have any questions</p>
		 */
		private function btnClickPublishGame():void
		{
			for (var s:int = 0; s < categoryList.length; s++)
			{
				if (categoryList[s]["items"] < 1)
				{
					categoryList.removeItemAt(s);
					s--;
				}
			}
			this.updateCategoryPos();
			if (categoryList.length > 0) this.setSelectedCategory(0);
		}
		private function get questionList():ArrayCollection
		{
			if (categoryList.length > 0)
			{
				return categoryList.getItemAt(_currentCategory).dataProvider;
			}
			return null;
		}
		]]>
</mx:Script>
	<mx:VBox top="5" bottom="5" left="5" right="5">
		<mx:Canvas height="50" width="100%">
			<mx:HBox left="5" right="5" height="40" verticalCenter="0" verticalAlign="middle">
				<mx:Label text="Widget Title: " styleName="sectionLabel"/>
				<mx:TextInput height="40" text="{instanceTitle}" maxChars="{CreatorConfig.MAX_TITLE_LENGTH}" change="{instanceTitle=txtGameTitle.text;}" focusIn="hightlight(event)" id="txtGameTitle" width="100%" styleName="titleField"/>
			</mx:HBox>
		</mx:Canvas>
		<mx:HBox horizontalGap="10" bottom="5" right="10" left="10" top="58" id="hbox1" width="100%" height="100%" styleName="creatorSectionMajor">
			<mx:Canvas id="categoryCanvas" width="0" visible="false" height="100%" cornerRadius="5" styleName="creatorSectionMinor">
				<mx:Canvas id="categoryBox" left="10" top="5" bottom="10" right="10">
					<mx:Canvas top="78" bottom="0" left="0" right="0" backgroundColor="#8F9B9E" backgroundAlpha="0.4">
						<mx:TileList id="categoryTL" dataProvider="{categoryList}" itemRenderer="renderers.categoryButton" selectedIndex="0" columnCount="1" maxColumns="1" right="0" left="0" bottom="0" top="0" styleName="HangmanTileList"></mx:TileList>
					</mx:Canvas>
					<mx:VBox left="0" right="0" top="0" >
						<mx:Label text="Categories: " height="30" styleName="sectionLabel"/>
						<mx:Button label="New Category" click="{newCategory()}" fontSize="15" icon="@Embed(source='/assets/materia/swf/kogneatoSymbols.swf#AddCategory')" height="30" id="btnNewCategory" fillAlphas="[1.0, 1.0, 1.0, 1.0]" styleName="gameButton"/>
					</mx:VBox>
				</mx:Canvas>
			</mx:Canvas>
			<mx:Canvas width="100%" height="100%" cornerRadius="5" styleName="creatorSectionMinor">
				<mx:VBox left="10" top="5" bottom="10" right="10">
					<mx:HBox width="100%">
						<mx:Label text="Questions: " styleName="sectionLabel"/>
						<mx:Button label="Add Question" click="{newQuestion()}" icon="@Embed(source='assets/materia/swf/kogneatoSymbols.swf#AddQuestion')" height="30" fillAlphas="[1.0, 1.0, 1.0, 1.0]" enabled="{questionList.length &lt; 25}" styleName="gameButton"/>
					</mx:HBox>
					<questionAnswerDataGrid:QuestionAnswerDataGrid id = "questionInputList"
					                                               width="100%"
					                                               height="100%"
					                                               answerHeaderLabel="Word"
					                                               questionHeaderLabel="Hint"
																   onInitAddInitialQuestion="false"
							/>
					<mx:HBox width="100%" verticalAlign="middle" horizontalGap="0">
						<mx:Label text="Options:" styleName="sectionLabel" />
						<mx:Canvas width="21" height="30">
						</mx:Canvas>
						<mx:Canvas width="336" height="40" styleName="creatorSectionMinor" horizontalScrollPolicy="off" verticalScrollPolicy="off" backgroundColor="#2C4B5F" borderColor="#2C4B5F">
							<mx:HBox verticalAlign="middle" horizontalScrollPolicy="off" verticalScrollPolicy="off" height="100%" left="5" right="5">
								<help:HelpDot toolTip="This determines how many mistakes are allowed per word."/>
								<mx:Label text="Attempts per Word:" styleName="wordSearchText"  />
								<mx:HSlider id="attemptsSlider"
								            minimum="3" maximum="7"
								            snapInterval="1"
								            change="{updateAttemptsOption()}"
								            width="138" height="31"
								            value="5" showDataTip="false"
								            labels="[3,4,5,6,7]"  styleName="creatorSlider"/>
							</mx:HBox>
						</mx:Canvas>
						<mx:Canvas width="21" height="30">
						</mx:Canvas>
						<mx:Canvas width="180" height="40" styleName="creatorSectionMinor" horizontalScrollPolicy="off" verticalScrollPolicy="off" backgroundColor="#2C4B5F" borderColor="#2C4B5F">
							<mx:HBox verticalAlign="middle" horizontalScrollPolicy="off" verticalScrollPolicy="off" height="100%" left="5" right="5">
								<help:HelpDot toolTip="When this option is checked, students will be scored based on the percentage of characters correctly entered per word. By default, this is unchecked."/>
								<mx:CheckBox label="Partial Scoring" id="partialScoring"  fontFamily="Verdana" color="#FFFFFF" fontSize="15"/>
							</mx:HBox>
						</mx:Canvas>
					</mx:HBox>
				</mx:VBox>
			</mx:Canvas>
		</mx:HBox>
		<mx:HRule width="100%"/>
	</mx:VBox>
</materia:CreatorBase>